{ pkgs, ... }:

let
  secrets = import ../secrets.nix;
in
{

  home.packages = with pkgs; [
    tig
    git-radar
    git-secrets # FIXME: add "install hook if you own the repository" warning on cd
    gitAndTools.git-extras
    gitAndTools.diff-so-fancy
    gitAndTools.hub
    gitAndTools.lab
    # gitAndTools.git-annex
  ];

  xdg.dataFile."git-hooks" = {
    executable = true;
    target = "../bin/git-hooks";
    source = pkgs.fetchurl {
      url = "https://raw.githubusercontent.com/icefox/git-hooks/master/git-hooks";
      sha256 = "1k9yb2g0gxld7vc0j0gjjp02k5l1fa8dsnafr9gdlzx373ypjqcj";
    };
  };
  # because they didn't use /usr/bin/env bash and I am too lazy to figure out how to strip it:
  home.file.".git_hooks/post-checkout-hooks/new-branch-alert.hook".text = ''
      #!/usr/bin/env bash
      # Based on a hook from gist.github.com
      # Source: https://gist.github.com/zgohr/4557894
      #
      # Creates a commit and displays a custom message when a new branch is checked out for the first time.
      # A commit is made in order to help determine if a new branch has been created.
      #
      # Requirements:
      #   * Bash
      #
      # To enable this hook, rename this file to "post-checkout".

      from_hash=$1
      to_hash=$2
      checkout_type=$3
      branch_name=$(git rev-parse --abbrev-ref HEAD)

      light_red='\033[1;31m'
      no_color='\033[0m'

      containsElement () {
          local e
          for e in "''${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
          return 1
      }

      if [ $checkout_type -ne 1 ]
      then
          exit 0 ; # Not a branch checkout
      fi

      if [ $from_hash != $to_hash ]
      then
          exit 0 ; # Not checking out a new branch
      fi

      # Create a commit and display a message
      git commit --allow-empty -m "Created branch $branch_name" --no-verify
      echo -e "\n''${light_red}Remember to change parent pom version to match branch name in every module!''${no_color}\n"
  '';

  home.file.".git_hooks/pre-push-hooks/prevent-bad-push.hook".text = ''
      #!/usr/bin/env bash
      # Based on the pre-push sample generated by default in .git/hooks
      # Source: https://www.git-scm.com/docs/githooks/1.7.1
      #
      # Prevents push of commits where the log message starts
      # with "WIP" (work in progress). Called by "git push" after
      # it has checked the remote status, but before anything has been pushed.
      #
      # The hook should exit with non-zero status after issuing an appropriate
      # message if it stops the push.
      #
      # Requirements:
      #   * Bash
      #
      # To enable this hook, rename this file to "pre-push".

      # This hook is called with the following parameters:
      #
      # $1 -- Name of the remote to which the push is being done
      # $2 -- URL to which the push is being done
      #
      # If pushing without using a named remote those arguments will be equal.
      #
      # Information about the commits which are being pushed is supplied as lines to
      # the standard input in the form:
      #
      #   <local ref> <local sha1> <remote ref> <remote sha1>

      remote="$1"
      url="$2"

      z40=0000000000000000000000000000000000000000

      while read local_ref local_sha remote_ref remote_sha
      do
        if [ "$local_sha" = $z40 ]
        then
          # Handle delete
          :
        else
          if [ "$remote_sha" = $z40 ]
          then
            # New branch, examine all commits
            range="$local_sha"
          else
            # Update to existing branch, examine new commits
            range="$remote_sha..$local_sha"
          fi

          # Check for WIP commit
          commit=`git rev-list -n 1 --grep '^WIP' "$range"`
          if [ -n "$commit" ]
          then
            echo >&2 "Found WIP commit in $local_ref, not pushing"
            exit 1
          fi

          commit=`git rev-list -n 1 --grep '^fixup!' "$range"`
          if [ -n "$commit" ]
          then
            echo >&2 "Found fixup commit in $local_ref, not pushing"
            exit 1
          fi
        fi
      done

      exit 0
  '';
  home.file.".git_hooks/pre-commit-hooks/spell-check-md-files.hook".source = pkgs.fetchurl {
    url = https://github.com/CompSciLauren/awesome-git-hooks/raw/master/pre-commit-hooks/spell-check-md-files.hook;
    sha256 = "0aj8lqqzzx992v8shkqdclwh4jv2vpcd8hkvxym9p7liv3fmfc7w";
  };
  home.file.".git_hooks/post-checkout-hooks/delete-pyc-files.hook".source = pkgs.fetchurl {
    url = https://github.com/CompSciLauren/awesome-git-hooks/raw/master/post-checkout-hooks/delete-pyc-files.hook;
    sha256 = "1ag8fsdcy64gvvkkm7mq7raic70cgda5lp7zzmyvdsb0r3sis62a";
  };
  programs.git = {
    enable = true;

    userName  = "Sam Stites";
    userEmail = "stites@users.noreply.github.com";

    signing = {
      key = secrets.gpg.signing-key;
      signByDefault = true;
    };

    aliases = {
      brn = "for-each-ref --sort=-committerdate refs/heads/ --format='%(committerdate:short) %(authorname) %(refname:short)'";
      btree = ''
        log \
          --all \
          --graph \
          --decorate=short \
          --color \
          --format=format:'%C(bold blue)%h%C(reset) %C(auto)%d%C(reset) %C(black)[%cr]%C(reset) %C(black)%an - %s %C(reset)'
      '';
    };

    ignores = [
      "*~"
      "*.swp"
      ".DS_Store"
      ".agignore"
      ".stites"
      "*/infinitest.filters"
      "codex.tags"
      "tags"
      "cscope.files"
      "cscope.out"
      "hscope.out"
      ".ghci"
      ".sosrc"
      ".envrc"
      ".envrc.bk"
      "tmp"
      "foo"
      "bar"
      "result"
      "?"
      ".myenv"
      "data/*.gz"
      ".syncthing*"
      "*.tmp"
      ".st*"
    ];

    lfs.enable = true;

    extraConfig = {
      rerere = {
        enabled = true;
        autoupdate = true;
      };
      core = {
        ignorecase = false;
        eol = "lf";
        whitespace = "blank-at-eol,space-before-tab,tab-in-indent,tabwidth=2";
        editor = "nvim";
      };
      color.ui = "auto";
      grep = {
        lineNumber = true;
        patternType = "perl";
      };
      advice = {
        pushNonFastForward = false;
        statusHints = false;
      };
      diff = {
        renames = "copies";
        mnemonicprefix = true;
      };
      pager = {
        diff = "${pkgs.gitAndTools.diff-so-fancy}/bin/diff-so-fancy | less --tabs=1,5 -RFX";
        show = "${pkgs.gitAndTools.diff-so-fancy}/bin/diff-so-fancy | less --tabs=1,5 -RFX";
      };
      branch.autosetupmerge = true;
      push.default = "tracking";

      merge = {
        stat = true;
        tool = "vimdiff";
      };

      help.autocorrect = 1;

      http.sslVerify = false;
      github.user = "stites";

      # [url "ssh://git@github.com/"]
      # insteadOf = https://github.com/

      # [url "git://github.com/ghc/packages-"]
      # insteadOf = git://github.com/ghc/packages/

      credential = {
        helper = "libsecret";
        # helper = store --file ~/.config/git/credentials
        # helper = cache --timeout=30000
      };

      # MANUAL LFS
      # [filter "lfs"]
      # smudge = git-lfs smudge -- %f
      # process = git-lfs filter-process
      # required = true
      # clean = git-lfs clean -- %f

      # [bulkworkspaces]
      # all = $HOME/git
    };
  };
}
